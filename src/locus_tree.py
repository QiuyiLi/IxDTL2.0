from .species_tree import *
from .tree_table import *

class LocusTree(SpeciesTree):

    def __init__(self, randomState):
        super().__init__(randomState=randomState)

    def initialize(self, nodes, skbioTree):
        self.treeTable = TreeTable()
        self.treeTable.createFromEntries(
            entries=nodes, skbioTree=skbioTree)

    # bounded coalescent for the locus tree model
    # keep trying until every gene merged in time
    def boundedCoalescent(self, distanceAboveRoot):
        coalescentProcess, genesIntoRoot = self.coalescent(distanceAboveRoot)
        if len(genesIntoRoot) == 1:
            return coalescentProcess
        else:
            return self.boundedCoalescent(distanceAboveRoot)

    # incomplete coalescent for IxDTL
    def incompleteCoalescent(self, distanceAboveRoot):
        coalescentProcess, genesIntoRoot = self.coalescent(distanceAboveRoot)
        chosenGene = np.random.choice(genesIntoRoot)
        selectedCoalescentProcess = self.__selectCoalescentProcess(
            coalescentProcess, chosenGene)
        return selectedCoalescentProcess, chosenGene
    
    # seclect one haplotype tree from multiple trees
    # sgenerated by the incomplete coalescent
    def __selectCoalescentProcess(self, coalescentProcess, chosenGene):
        selectedCoalescentProcess = defaultdict(list)
        for speciesNodeId, mergingSets in coalescentProcess.items():
            for mergingSet in mergingSets:
                distance = mergingSet['distance']
                fromSet = []
                toSet = []
                for clade in mergingSet['fromSet']:
                    if self._starInSet(target=clade, clade=chosenGene):
                        fromSet.append(clade)
                if mergingSet['toSet']:
                    for clade in mergingSet['toSet']:
                        if self._starInSet(target=clade, clade=chosenGene):
                            toSet.append(clade)
                    if toSet:
                        selectedCoalescentProcess[speciesNodeId].append({
                            'fromSet': fromSet, 
                            'toSet': toSet,
                            'distance': distance
                        })
        return selectedCoalescentProcess

    def unlinkingProcess(self, distanceAboveRoot, event):
        unlinkPoints = [] 
        unlinkedSpecies = []
        for e in self.getLeaves():
            unlinkedSpecies.append(e.id)
        if len(self.getNodes()) == 1:
            distanceAboveRoot = event['distanceToSpeciesNode']
        self.__unlinkingProcessRecurse(
            skbioTreeNode=self.getSkbioTree(), 
            distanceAboveRoot=distanceAboveRoot, 
            unlinkPoints=unlinkPoints, unlinkedSpecies=unlinkedSpecies)
        return unlinkPoints, unlinkedSpecies

    def __unlinkingProcessRecurse(self, skbioTreeNode, distanceAboveRoot, unlinkPoints, unlinkedSpecies):
        node = self.getNodeByName(skbioTreeNode.name)
        unlinkRate = 1.0
        distanceU = self.randomState.exponential(
            scale=1.0 / unlinkRate)

        if (distanceU < distanceAboveRoot):      
            eventHeight = self.getDistanceToLeaf(node.id, 0) + distanceAboveRoot - distanceU
            unlinkPoints.append({
                'SpeciesNodeId': node.id,      # closest gene node to the event from below 
                'distanceToSpeciesNode': distanceAboveRoot - distanceU,
                'eventHeight': eventHeight,
            })
        else:
            # reach the end the current branch, looking for events in the 2 children branches
            if (node.children):     # if children branches exist
                childL = skbioTreeNode.children[0]
                childR = skbioTreeNode.children[1]
                distanceToChildL = node.distanceToChildren[0]
                distanceToChildR = node.distanceToChildren[1]
                self.__unlinkingProcessRecurse(
                    skbioTreeNode=childL, 
                    distanceAboveRoot=distanceToChildL, 
                    unlinkPoints=unlinkPoints, linkedSpecies=unlinkedSpecies)
                self.__unlinkingProcessRecurse(
                    skbioTreeNode=childR, 
                    distanceAboveRoot=distanceToChildR, 
                    unlinkPoints=unlinkPoints, linkedSpecies=unlinkedSpecies)
            else:
                unlinkedSpecies.remove(node.id)
            # else: if not exist, reach the leaves of the tree, searching process stops
